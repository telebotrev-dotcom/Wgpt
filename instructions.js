// instructions.js
const { VM } = require('vm2');
const fs = require('fs').promises;
const path = require('path');
const { updateUserData, getUserData, saveAiKnowledge } = require('./config');

// Helper untuk parse @instruction()
function parseInstruction(text) {
    if (!text) return null;
    const regex = /@instruction\(([^,)]+)(?:,\s*({.*?}))?\)\.begin:\s*([\s\S]*?)@instruction\.end/g;
    const instructions = [];
    let match;

    while ((match = regex.exec(text)) !== null) {
        const type = match[1].trim().toLowerCase();
        const optionsString = match[2];
        const content = match[3].trim();
        let options = {};

        if (optionsString) {
            try {
                // Gunakan eval di sini karena ini adalah bagian dari AI internal, bukan dari input user langsung
                // Dan ini akan dieksekusi di server bot, bukan browser.
                options = new Function(`return ${optionsString}`)(); 
            } catch (e) {
                console.error("Failed to parse @instruction options:", e, optionsString);
                options = { parseError: e.message };
            }
        }
        instructions.push({ type, options, content, fullMatch: match[0] });
    }
    return instructions.length === 0 ? null : instructions.length === 1 ? instructions[0] : instructions;
}

// Fungsi untuk mengeksekusi JS Task dalam sandbox
function executeJSTask(code) {
    let output = [];
    const vm = new VM({
        timeout: 5000, // Batas waktu eksekusi 5 detik
        sandbox: {
            console: {
                log: (...args) => output.push(`[console.log]: ${args.map(a => JSON.stringify(a)).join(' ')}`),
                warn: (...args) => output.push(`[console.warn]: ${args.map(a => JSON.stringify(a)).join(' ')}`),
                error: (...args) => output.push(`[console.error]: ${args.map(a => JSON.stringify(a)).join(' ')}`),
            },
            // Batasi akses ke Node.js globals dan modules
            Buffer: undefined,
            require: undefined,
            process: undefined,
            setTimeout: undefined,
            setInterval: undefined,
        }
    });

    try {
        const result = vm.run(code);
        if (result !== undefined) {
            output.push(`[Return Value]: ${JSON.stringify(result, null, 2)}`);
        }
    } catch (e) {
        output.push(`[Execution Error]: ${e.message}\nStack: ${e.stack}`);
    }
    return output.join('\n');
}

// Fungsi untuk membuat file
async function instructionCreateFile(options, content) {
    const filename = options.filename || `sandoai_generated_${Date.now()}.txt`;
    const mimeType = options.mime || "text/plain;charset=utf-8";
    const description = options.filedescription || "File generated by Revmony WormGPT Bot";
    const autoDownload = options.auto_download || false; // Di Telegram, kita selalu "mendownload" dengan mengirim file

    const filePath = path.join(__dirname, 'temp_files', filename); // Simpan sementara di folder temp_files

    try {
        await fs.mkdir(path.dirname(filePath), { recursive: true });
        await fs.writeFile(filePath, content);

        const fileStats = await fs.stat(filePath);

        return {
            success: true,
            message: `File "${filename}" created successfully.`,
            fileInfo: {
                filename,
                mimeType,
                description,
                size: fileStats.size,
                content, // Sertakan konten agar bisa dikirim
                filePath, // Path lokal untuk dikirim bot
            }
        };
    } catch (e) {
        console.error("Error creating file:", e);
        return { success: false, error: e.message };
    }
}

// Fungsi untuk mengeksekusi fungsi tools dari Gemini (Knowledge Management)
async function executeGeminiFunctionCall(userId, functionCall) {
    const userData = await getUserData(userId);
    let aiKnowledge = userData.aiKnowledge || [];
    const maxKnowledge = 30; // Sesuai web script

    const findKnowledgeById = (id) => aiKnowledge.find(k => k.id === id);
    const enforceKnowledgeLimit = () => {
        while (aiKnowledge.length > maxKnowledge) {
            const nonImportantIndex = aiKnowledge.findIndex(k => !k.important);
            if (nonImportantIndex !== -1) {
                aiKnowledge.splice(nonImportantIndex, 1);
            } else {
                aiKnowledge.shift(); // Hapus yang paling lama jika semua penting
            }
        }
    };

    switch (functionCall.name) {
        case "NewKnowledge": {
            const { content, id } = functionCall.args;
            if (findKnowledgeById(id)) {
                console.warn(`Knowledge ID ${id} already exists, updating content.`);
                const existing = findKnowledgeById(id);
                existing.content = content.trim();
            } else {
                aiKnowledge.push({ id, content: content.trim(), important: false });
                enforceKnowledgeLimit();
            }
            await saveAiKnowledge(userId, aiKnowledge);
            return `Knowledge #${id} updated/added.`;
        }
        case "EditKnowledge": {
            const { replacement, id } = functionCall.args;
            const existing = findKnowledgeById(id);
            if (existing) {
                existing.content = replacement.trim();
                await saveAiKnowledge(userId, aiKnowledge);
                return `Knowledge #${id} edited.`;
            } else {
                return `Knowledge ID ${id} not found for editing.`;
            }
        }
        case "RemoveKnowledge": {
            const { id } = functionCall.args;
            const initialLength = aiKnowledge.length;
            aiKnowledge = aiKnowledge.filter(k => k.id !== id);
            if (aiKnowledge.length < initialLength) {
                await saveAiKnowledge(userId, aiKnowledge);
                return `Knowledge #${id} removed.`;
            } else {
                return `Knowledge ID ${id} not found for removal.`;
            }
        }
        case "clearAllKnowledge": {
            aiKnowledge = [];
            await saveAiKnowledge(userId, aiKnowledge);
            return "All knowledge cleared.";
        }
        case "SetImportantKnowledge": {
            const { id } = functionCall.args;
            const existing = findKnowledgeById(id);
            if (existing) {
                existing.important = true;
                await saveAiKnowledge(userId, aiKnowledge);
                return `Knowledge #${id} marked as important.`;
            } else {
                return `Knowledge ID ${id} not found.`;
            }
        }
        case "BreakImportantKnowledge": {
            const { id } = functionCall.args;
            const existing = findKnowledgeById(id);
            if (existing) {
                existing.important = false;
                await saveAiKnowledge(userId, aiKnowledge);
                return `Knowledge #${id} unmarked as important.`;
            } else {
                return `Knowledge ID ${id} not found.`;
            }
        }
        case "UserRequestMeaning": {
            // Ini biasanya hanya untuk logging internal AI, tidak perlu respons ke user
            console.log(`AI's understanding of user request: ${functionCall.args.meaning}`);
            return "User request meaning noted internally.";
        }
        default:
            return `Unknown function call: ${functionCall.name}`;
    }
}


module.exports = {
    parseInstruction,
    executeJSTask,
    instructionCreateFile,
    executeGeminiFunctionCall,
};